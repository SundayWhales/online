# Chapter 1. Becoming functional

- FP 의 함수형 용어를 생각하기
- 무엇이 FP 고, 왜 FP 인지 배우기
- 불변함 그리고 순수한 함수의 원리를 이해하기
- FP 기술들과 전체적인 설계에 미치는 영향



> OO 는 동작부분을 캡슐화 함으로써 코드를 이해할 수 있도록 만든다.
>
> FP   는 동작부분을 최소화 함으로써 코드를 이해할 수 있도록 만든다.
>
> Michael Feathers (Twitter)



### JavaScript 를 구조화되고 잘 설계해야하는 이유

한마디로 <u>dynamic language</u> 라서

OOP 책에서 본것과 동일하기 때문에 비슷한 내용은 최대한 생략했습니다 …….

……. 라고 했지만.. 글쓴이를 위해 좀더 보태보자면,

1. 코드베이스의 복잡성이 컨트롤을 벗어나게 되면, 우리는 코드의 기본 설계 원리를 재검해봐야 한다
2. 웹개발 세상은 참 빠르게 달라지고 있고, 전과 비교했을 때 기술적으로 할 수 있는 것들이 많이 있다
3. 대규모 서버사이드 어플리케이션으로 Node.js 를 사용해서 Javascript 로도 대규모 서비스 단위 코드 작성 할 수 있다.
4. 클라이언트도, 스토리지 기술과 상호 작용하고 비동기 프로세스를 생성하며 이벤트를 처리해야 한다

**----- 확장성 있고 클린 코드 앱 구조를 만들어야 하는 이유가 되겠다**



### 그렇다면 OOP 보다 FP 를 선택해야하는 이유는 뭘까?

- OOP 는 다루거나 유지하기가 어려울 정도로 복잡한 JavaScript 를 제어할 수 있도록 도와준다
- Reactive Programming 는 데이터 흐름 및 변경 전파에 대한 작업을 용이하게 해준다
  - 이는 JavaScript 에서 비동기, 이벤트 기반의 코드를 다루는데 정말정말정말 중요하다.

그러나 이보다 더 중요한 것 ***우리가 정말 필요한 것이 무엇인가***  이다.

"프로그래밍 패러다임" 은 

우리가 데이터, 그리고 데이터와 상호 작용하는 기능들에 대해 신중하게 생각하도록 장려해준다. 

그렇다면 실제로 우리가 앞서 말한 설계원리들(oop, rp) 의 관점에서 아래의 질문들에 스스로 답해보세용

- 확장성 - 추가 기능을 지원하기 위해 코드를 지속적으로 리팩토링 하나요?
- 모듈화하기 쉬운지 - 만일 내가 한 파일을 바꾸면, 다른 파일에 영향이 가나요?
- 재사용성 - 중복이 많이 있어요?
- 테스트 가능성 - 내 기능을 유닛테스트하는데 힘들지 않아요?
- 추론하기 쉬운지 - 내 코드가 구조화되어 있지 않고 따르기가 어렵진 않아요?

대답이 "Yes" 이거나 "I don't know" 라면 FP 가 딱 원하는 프로그래밍 패러다임 이다.

FP 는 새로운 툴이나 API 가 아니라,

기본 원리를 이해하면 직관적으로 파바박- 될 수 있는 뭔가  *<u>다른 관점</u>*  이다.



### 1.1. FP 가 도울 수 있는 점

함수형 JavaScript 코드를 작성하는 것은 위의 많은 우려들을 해결한다 (끝)



**여기서 드는 생각,**

> 그런데… 어떻게 함수형으로 할 수 있을까?, 어떻게 함수형으로 생각하기 시작할까? 

일단! 기능적으로 생각하는 것은 객체 지향적으로 생각하는 것과 근본적으로 다르다. 

FP 는 일단 그 본질을 파악해야 한다.



### 1.2. 뭐지 FP?

FP 는 **함수 사용에 큰 중요성을 두는** 소프트웨어 개발 스타일 이다.

-> 음. 난 이미 함수를 사용해 매일 일하면서, 근데 뭐가 달라?

FP 는 ***우리가 직면하는 일들을 어떻게 접근할지***  좀 많이 마니 다르게 생각하는 것이 필요하다.

그냥 단순히 함수를 적용하는 것만이 중점이 아니닷.

더 나아가, 목표!!

- abstract control flows (제어프름을 추상화)
- operations on data (데이터 조작)
- avoid side effects (사이드이팩트-부작용 피하기)
- reduce mutation of state (상태 돌연변이-변화를 줄이기)

이 모든걸 **함수** 로 코드에 적용해야 한다. 



그렇다면, 간단하게 HTML page 에 텍스트를 보여주는 코드로 한번 시작해보자.



#### Thinking 1.

ol"Hello World"  보다 저 나은 텍스트는 뭘깡

```javascript
document.querySelector('#msg').innerHTML = '<h1>Hello World</h1>';
```

요건 간단해 보이지만 모든게 하드코딩 되어있다. 문제는 메시지를 동적으로 보여주는데에는 사용할 수 없다. 포맷, 컨텐트, 타겟 엘리먼트를 바꾸고 싶으면 전체 표현식을 다시 써야한다.



#### Thinking 2.

예상대로라면, 우리는 그 코드를 함수화해서 어떤 지점의 변수를 변경할 수 있도록 결정할 것이다.

짠

```javascript
function printMessage(elementId, format, message) {
     document.querySelector(`#${elementId}`).innerHTML =
         `<${format}>${message}</${format}>`;
}

printMessage('msg', 'h1','Hello World');
```

실제로 이 코드는 나아진 것은 사실이지만, 여전히 완전하게 재사용할 수 있는 것은 아니다.

만일 HTML 페이지 대신 파일에 작성하길 원한다면?



#### Thinking 3.

*FP 로서 - 전혀 다른 레벨로, **함수자체를 변수화** 하도록 만드는 간단한 <u>생각 프로세스</u>를 가져야 한다.*

​	-> 매개 변수가 그냥 그 작은 값이 아니라, 추가 기능을 제공하는 함수 자체일 거라는 생각을…!!

```javascript
var printMessage = run(addToDom('msg'), h1, echo);

printMessage('Hello World');
```

h1 이건 더이상 변수가 아니다, addToDom 과 echo 같은 함수로 봐야 한다.

보이는 것처럼, <u>작은 함수들로부터 하나의 함수를 만드는</u> 바로 이 느낌적인 느낌!

이것은 

1. 프로그램을 더 재사용 가능하게 하고
2. 신뢰성이 높으며 
3. 이해하기 쉬운 작은 조각으로 분해 -> 결합하여 
4. 전체적으로 추론하기 쉬운 

전체 프로그램을 구성하는 과정을 보여준다.

 "**run**" 요거슨 시간이 지나면, 환상적인 함수로 사용할 것이다.

addToDom - h1 - echo 를 순차적으로 일련의 함수들을 호출하는 방식으로서, 체인 함수와 같은 방식으로 각 함수를 연결하여 반환 값을 입력 값으로 전달한다. 즉, echo 에서 반환된 문자열 "Hello World" 가 h1 으로 전달되고 결과가 마지막으로 addToDom 으로 전달되는 방식



간단하게 말하자면, 기본적으로 쉽게 변경할 수 있도록 ***코드를 매개 변수화*** 한다고 생각하면 된다.

만일, 추가기능으로 "메시지를 두번 반복하기!!" 로 printMessage 를 확장해보자

그럼 이렇게 할 수 있다.

```javascript
var printMessage = run(console.log, repeat(3), h2, echo);

printMessage('Get Functional');
```

이 방법은 함수를 두벌씩 작성하는 것도 아니다.

그리고 이 방식은 **FP 에서 선언적 프로그래밍(Declarative programming**) 이다.

앞으로 계속해서 FP 를 완전히 이해하기 위해서는 먼저 **<u>FP 의 기본 개념</u>**을 알아야 한다.

- Declarative programming (선언적 프로그래밍)
- Pure functions (순수 함수)
- Referential transparency (참조 투명성)
- Immutability (불변성)

…….을 다음 번에..!! 이번주는 여기까지만…!!